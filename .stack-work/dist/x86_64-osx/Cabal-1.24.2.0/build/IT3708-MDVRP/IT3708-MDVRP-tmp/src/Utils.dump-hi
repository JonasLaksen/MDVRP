
==================== FINAL INTERFACE ====================
2017-02-26 13:15:55.342669 UTC

interface main@main:Utils [hpc] 8002
  interface hash: cdfde6708ab65ace8ba10385fb6610b9
  ABI hash: 0a3968a4b35df5acb7686f2cf2f95ca7
  export-list hash: 91e228bb62228bf6da922e180065cfc8
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 875509f7f502afeef2e0160fba8f350f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Utils.distance
  Utils.insertInto
  Utils.insertInto'
  Utils.position
  Utils.prettyCustomer
  Utils.prettyRoute
  Utils.prettySolution
  Utils.shrink
  Utils.swap
  Utils.swapElementsAt
  Utils.totalDistance
module dependencies: Types
package dependencies: base-4.9.1.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:Debug.Trace a9edf3aec504f4423d8ba829ab373a25
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Float 33e2b9ffe427edd6a5c2fd6a3b26703c
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  Types 84d440671d91bc7127fd44e7871db9b3
  exports: 031c722d2eaf5c00cf8059beff2d5b0e
  Customer f75d8487e3b128e128ef94d19db2ae50
  Entity ff31e4bda671bf82b6a5ed878955602f
  Point 4566a5dabcd3c5255e6731e0b7be94ba
  Route 1575af41b020866d7a49276c2048a2ed
291106054c4d8b27d6c9c922ac6045fc
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Utils.$trModule2 Utils.$trModule1) -}
6a4d1fe5f096b432355a31315328d1d2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Utils"#) -}
1e6be541f8d090dab52c7f466e538240
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
da9579ee8bd85285ba689ad0b124bc6d
  $winsertInto' :: a -> GHC.Prim.Int# -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U><L,U>,
     Inline: [0] -}
3d4f30891018d3ebd08da90c0299a216
  distance :: Types.Point -> Types.Point -> GHC.Types.Float
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)S(S)),1*U(1*U(U),1*U(U))><S(S(S)S(S)),1*U(1*U(U),1*U(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: (GHC.Types.Int, GHC.Types.Int))
                   (ds1 :: (GHC.Types.Int, GHC.Types.Int)) ->
                 {__scc {main@main:Utils.distance} True True} case ds of wild { (,) a1 a2 ->
                                                              case ds1 of wild1 { (,) b1 b2 ->
                                                              case a1 of wild2 { GHC.Types.I# x ->
                                                              case b1 of wild3 { GHC.Types.I# y ->
                                                              case a2 of wild4 { GHC.Types.I# x1 ->
                                                              case b2 of wild5 { GHC.Types.I# y1 ->
                                                              let {
                                                                x2 :: GHC.Prim.Int#
                                                                = GHC.Prim.-# x1 y1
                                                              } in
                                                              let {
                                                                x3 :: GHC.Prim.Int#
                                                                = GHC.Prim.-# x y
                                                              } in
                                                              GHC.Types.F#
                                                                (GHC.Prim.sqrtFloat#
                                                                   (GHC.Prim.int2Float#
                                                                      (GHC.Prim.+#
                                                                         (GHC.Prim.*# x3 x3)
                                                                         (GHC.Prim.*#
                                                                            x2
                                                                            x2)))) } } } } } }) -}
60cd49ced65904c6638f8b1311317d83
  insertInto :: a -> GHC.Types.Int -> [[a]] -> [[a]]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,1*U(U)><S,1*U> -}
10e87da631121b2189367e2508f280cb
  insertInto' :: a -> GHC.Types.Int -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S(S),1*U(1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: a) (w1 :: GHC.Types.Int) (w2 :: [a]) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Utils.$winsertInto' @ a w ww1 w2 }) -}
e0d6857d66be1fdb82013b42479cd2b8
  position :: Types.Entity -> Types.Point
  {- Arity: 1, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [GHC.Types.Int]) ->
                 {__scc {main@main:Utils.position} True True} case ds of wild {
                                                                [] -> Utils.position1
                                                                : ds1 ds2
                                                                -> case ds2 of wild1 {
                                                                     [] -> Utils.position1
                                                                     : x ds3
                                                                     -> case ds3 of wild2 {
                                                                          [] -> Utils.position1
                                                                          : y ds4
                                                                          -> (x, y) } } }) -}
14dbc72b8f1aead2bab5e47526a5d26d
  position1 :: Types.Point
  {- Strictness: x -}
0414b30a73283c4d3734d0a5e7937663
  prettyCustomer :: Types.Customer -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [GHC.Types.Int]) ->
                 {__scc {main@main:Utils.prettyCustomer} True True} case ds of wild {
                                                                      [] -> Utils.prettyCustomer1
                                                                      : id ds1 -> id }) -}
0a8e0f757ca987c16a9d98c51f13c98e
  prettyCustomer1 :: GHC.Types.Int
  {- Strictness: x -}
35ac50bf36f254a8d9e10e2d38323658
  prettyRoute :: Types.Route -> [GHC.Types.Int]
  {- Unfolding: ({__scc {main@main:Utils.prettyRoute} True True} GHC.Base.map
                                                                   @ Types.Customer
                                                                   @ GHC.Types.Int
                                                                   Utils.prettyCustomer) -}
d5d789de79d263e0e5fd6d27d11a10ae
  prettySolution :: [Types.Route] -> [[GHC.Types.Int]]
  {- Unfolding: ({__scc {main@main:Utils.prettySolution} True True} GHC.Base.map
                                                                      @ Types.Route
                                                                      @ [GHC.Types.Int]
                                                                      Utils.prettyRoute) -}
de80f07ace7064304be59a7fdd849241
  shrink :: [[a]] -> [[a]]
  {- Unfolding: (\ @ a ->
                 {__scc {main@main:Utils.shrink} True True} GHC.List.filter
                                                              @ [a]
                                                              (Utils.shrink1 @ a)) -}
3269bcb352b31ab15d3b52277a6aeb63
  shrink1 :: [a] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (x :: [a]) ->
                 {__scc {main@main:Utils.shrink} False True} {__scc {main@main:Utils.shrink.\} True True} case GHC.List.$wlenAcc
                                                                                                                 @ a
                                                                                                                 x
                                                                                                                 0# of ww2 { DEFAULT ->
                                                                                                          GHC.Prim.tagToEnum#
                                                                                                            @ GHC.Types.Bool
                                                                                                            (GHC.Prim.>#
                                                                                                               ww2
                                                                                                               0#) }) -}
f6795b63defe4e7f697cfdc09ca68749
  swap :: GHC.Types.Int -> [a] -> [a]
  {- Arity: 2, Strictness: <L,1*U(1*U)><S,1*U> -}
0fdafd0464725aeaf65d394ae72ed06c
  swapElementsAt :: GHC.Types.Int -> GHC.Types.Int -> [t] -> [t]
  {- Arity: 3, Strictness: <L,U(U)><L,U(U)><S,U>,
     Unfolding: (\ @ t
                   (i :: GHC.Types.Int)
                   (j :: GHC.Types.Int)
                   (ls :: [t]) ->
                 let {
                   lvl2 :: t
                   = {__scc {main@main:Utils.swapElementsAt} False True} {__scc {main@main:Utils.swapElementsAt.get} False True} GHC.List.!!
                                                                                                                                   @ t
                                                                                                                                   ls
                                                                                                                                   j
                 } in
                 {__scc {main@main:Utils.swapElementsAt} True True} case GHC.List.$wlenAcc
                                                                           @ t
                                                                           ls
                                                                           0# of ww2 { DEFAULT ->
                                                                    let {
                                                                      y :: GHC.Prim.Int#
                                                                      = GHC.Prim.-# ww2 1#
                                                                    } in
                                                                    case GHC.Prim.tagToEnum#
                                                                           @ GHC.Types.Bool
                                                                           (GHC.Prim.>#
                                                                              0#
                                                                              y) of wild {
                                                                      GHC.Types.False
                                                                      -> letrec {
                                                                           go :: GHC.Prim.Int#
                                                                                 -> [t] -> [t]
                                                                             {- Arity: 2,
                                                                                Strictness: <L,U><S,1*U> -}
                                                                           = \ (x :: GHC.Prim.Int#)
                                                                               (eta :: [t]) ->
                                                                             case eta of wild1 {
                                                                               []
                                                                               -> GHC.Types.[] @ t
                                                                               : y1 ys
                                                                               -> GHC.Types.:
                                                                                    @ t
                                                                                    ({__scc {main@main:Utils.swapElementsAt.get} True True} case i of wild2 { GHC.Types.I# y2 ->
                                                                                                                                            case GHC.Prim.tagToEnum#
                                                                                                                                                   @ GHC.Types.Bool
                                                                                                                                                   (GHC.Prim.==#
                                                                                                                                                      x
                                                                                                                                                      y2) of wild3 {
                                                                                                                                              GHC.Types.False
                                                                                                                                              -> case j of wild4 { GHC.Types.I# y3 ->
                                                                                                                                                 case GHC.Prim.tagToEnum#
                                                                                                                                                        @ GHC.Types.Bool
                                                                                                                                                        (GHC.Prim.==#
                                                                                                                                                           x
                                                                                                                                                           y3) of wild5 {
                                                                                                                                                   GHC.Types.False
                                                                                                                                                   -> y1
                                                                                                                                                   GHC.Types.True
                                                                                                                                                   -> GHC.List.$w!!
                                                                                                                                                        @ t
                                                                                                                                                        ls
                                                                                                                                                        y2 } }
                                                                                                                                              GHC.Types.True
                                                                                                                                              -> lvl2 } })
                                                                                    (case GHC.Prim.tagToEnum#
                                                                                            @ GHC.Types.Bool
                                                                                            (GHC.Prim.==#
                                                                                               x
                                                                                               y) of wild2 {
                                                                                       GHC.Types.False
                                                                                       -> go
                                                                                            (GHC.Prim.+#
                                                                                               x
                                                                                               1#)
                                                                                            ys
                                                                                       GHC.Types.True
                                                                                       -> GHC.Types.[]
                                                                                            @ t }) }
                                                                         } in
                                                                         go 0# ls
                                                                      GHC.Types.True
                                                                      -> GHC.Types.[] @ t } }) -}
411ab2eddd09b1a588fb13ab75c4af0d
  totalDistance :: [Types.Point] -> GHC.Types.Float
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ccs :: [Types.Point]) ->
                 {__scc {main@main:Utils.totalDistance} True True} case ccs of wild {
                                                                     [] -> Utils.totalDistance2
                                                                     : c circle
                                                                     -> letrec {
                                                                          $wgo :: [(GHC.Types.Int,
                                                                                    GHC.Types.Int)]
                                                                                  -> (# (GHC.Types.Int,
                                                                                         GHC.Types.Int),
                                                                                        GHC.Types.Float #)
                                                                            {- Arity: 1,
                                                                               Strictness: <S,1*U>,
                                                                               Inline: [0] -}
                                                                          = \ (w :: [(GHC.Types.Int,
                                                                                      GHC.Types.Int)]) ->
                                                                            case w of wild1 {
                                                                              []
                                                                              -> (# c,
                                                                                    Utils.totalDistance1 #)
                                                                              : y ys
                                                                              -> {__scc {main@main:Utils.totalDistance.\} True False} (# y,
                                                                                                                                         case $wgo
                                                                                                                                                ys of ww { (#,#) ww1 ww2 ->
                                                                                                                                         case ww1 of ww3 { (,) ww4 ww5 ->
                                                                                                                                         case ww4 of ww6 { GHC.Types.I# ww7 ->
                                                                                                                                         case ww5 of ww8 { GHC.Types.I# ww9 ->
                                                                                                                                         case ww2 of ww10 { GHC.Types.F# ww11 ->
                                                                                                                                         {__scc {main@main:Utils.totalDistance.\} False True} {__scc {main@main:Utils.distance} True False} case y of wild2 { (,) a1 a2 ->
                                                                                                                                                                                                                                            case a1 of wild3 { GHC.Types.I# x ->
                                                                                                                                                                                                                                            case a2 of wild4 { GHC.Types.I# x1 ->
                                                                                                                                                                                                                                            case {__scc {main@main:Utils.distance} False True} let {
                                                                                                                                                                                                                                                                                                 x2 :: GHC.Prim.Int#
                                                                                                                                                                                                                                                                                                 = GHC.Prim.-#
                                                                                                                                                                                                                                                                                                     x
                                                                                                                                                                                                                                                                                                     ww7
                                                                                                                                                                                                                                                                                               } in
                                                                                                                                                                                                                                                                                               let {
                                                                                                                                                                                                                                                                                                 x3 :: GHC.Prim.Int#
                                                                                                                                                                                                                                                                                                 = GHC.Prim.-#
                                                                                                                                                                                                                                                                                                     x1
                                                                                                                                                                                                                                                                                                     ww9
                                                                                                                                                                                                                                                                                               } in
                                                                                                                                                                                                                                                                                               GHC.Types.F#
                                                                                                                                                                                                                                                                                                 (GHC.Prim.sqrtFloat#
                                                                                                                                                                                                                                                                                                    (GHC.Prim.int2Float#
                                                                                                                                                                                                                                                                                                       (GHC.Prim.+#
                                                                                                                                                                                                                                                                                                          (GHC.Prim.*#
                                                                                                                                                                                                                                                                                                             x2
                                                                                                                                                                                                                                                                                                             x2)
                                                                                                                                                                                                                                                                                                          (GHC.Prim.*#
                                                                                                                                                                                                                                                                                                             x3
                                                                                                                                                                                                                                                                                                             x3)))) of wild5 { GHC.Types.F# y1 ->
                                                                                                                                                                                                                                            GHC.Types.F#
                                                                                                                                                                                                                                              (GHC.Prim.plusFloat#
                                                                                                                                                                                                                                                 ww11
                                                                                                                                                                                                                                                 y1) } } } } } } } } } #) }
                                                                        } in
                                                                        case $wgo
                                                                               wild of ww { (#,#) ww1 ww2 ->
                                                                        ww2 } }) -}
7000c677698ffa9d9484cec49d22b7af
  totalDistance1 :: GHC.Types.Float
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.F# 0.0#) -}
dc911029f539140e6045f7d7b35e4002
  totalDistance2 :: GHC.Types.Float
  {- Strictness: x -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

